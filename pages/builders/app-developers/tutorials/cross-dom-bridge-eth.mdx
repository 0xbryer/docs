---
title: Bridging ETH with Viem
lang: en-US
description: Learn how to use Viem to transfer ETH between Layer 1 (Ethereum or Sepolia) and Layer 2 (OP Mainnet or OP Sepolia).
---

import { Callout, Steps, Tabs } from 'nextra/components'

# Bridging ETH to OP Mainnet With Viem

This tutorial explains how you can use [Viem](https://viem.sh) to bridge ETH from L1 (Ethereum or Sepolia) to L2 (OP Mainnet or OP Sepolia).
Viem is a TypeScript interface for Ethereum that provides low-level stateless primitives for interacting with Ethereum.
It offers an easy way to add bridging functionality to your JavaScript-based application.

Behind the scenes, Viem uses the [Standard Bridge](/builders/app-developers/bridging/standard-bridge) contracts to transfer ETH and ERC-20 tokens.
Make sure to check out the [Standard Bridge guide](/builders/app-developers/bridging/standard-bridge) if you want to learn more about how the bridge works under the hood.

## Supported Networks

Viem supports any of the [Superchain networks](/chain/networks).
The OP Stack networks are included in Viem by default.
If you want to use a network that isn't included by default, you can add it to Viem's chain configurations.

## Dependencies

*   [node](https://nodejs.org/en/)
*   [pnpm](https://pnpm.io/installation)

## Create a Demo Project

You're going to use Viem for this tutorial.
Since Viem is a [Node.js](https://nodejs.org/en/) library, you'll need to create a Node.js project to use it.

<Steps>
  {<h3>Make a Project Folder</h3>}

  ```bash
  mkdir op-sample-project
  cd op-sample-project
  ```

  {<h3>Initialize the Project</h3>}

  ```bash
  pnpm init
  ```

  {<h3>Install the Optimism SDK</h3>}

  Install `viem`, and `dotenv` for managing environment variables.

  ```bash
  pnpm add viem dotenv
  ```
</Steps>

<Callout type="info">
  Want to create a new wallet for this tutorial?
  If you have [`cast`](https://book.getfoundry.sh/getting-started/installation) installed you can run `cast wallet new` in your terminal to create a new wallet and get the private key.
</Callout>

## Get ETH on Sepolia

This tutorial explains how to bridge ETH from Sepolia to OP Sepolia.
You will need to get some ETH on Sepolia to follow along.

<Callout type="info">
  You can use [this faucet](https://sepoliafaucet.com) to get ETH on Sepolia.
</Callout>

## Add a Private Key to Your Environment

You need a private key in order to sign transactions.
Set your private key as an environment variable with the export command.
Make sure this private key corresponds to an address that has ETH on Sepolia.

```bash
export TUTORIAL_PRIVATE_KEY=0x...
```

## Start the Node REPL

You're going to use the Node REPL to interact with Viem.
To start the Node REPL run the following command in your terminal:

```bash
node
```

This will bring up a Node REPL prompt that allows you to run JavaScript code.

## Import Dependencies

You need to import some dependencies into your Node REPL session.

```js
const { createPublicClient, http, createWalletClient, parseEther, formatEther } = require('viem');
const { sepolia, optimismSepolia } = require('viem/chains');
const { privateKeyToAccount } = require('viem/accounts');
const { getL2TransactionHashes, publicActionsL1, publicActionsL2, walletActionsL1, walletActionsL2 } = require('viem/op-stack');

// Load private key from environment variable
const PRIVATE_KEY = process.env.TUTORIAL_PRIVATE_KEY;
const account = privateKeyToAccount(PRIVATE_KEY);

// Create L1 public client for reading from the Sepolia network
const publicClientL1 = createPublicClient({
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
}).extend(publicActionsL1())

// Create L1 wallet client for sending transactions on Sepolia
const walletClientL1 = createWalletClient({
    account,
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
}).extend(walletActionsL1());

// Create L2 public client for interacting with OP Sepolia
const publicClientL2 = createPublicClient({
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
}).extend(publicActionsL2());

// Create L2 wallet client for sending transactions on OP Sepolia
const walletClientL2 = createWalletClient({
    account,
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
}).extend(walletActionsL2());
```

## Get ETH on Sepolia

You're going to need some ETH on L1 that you can bridge to L2.
You can get some Sepolia ETH from [this faucet](https://sepoliafaucet.com).

## Deposit ETH

Now that you have some ETH on L1 you can deposit that ETH into the `L1StandardBridge` contract. You'll then receive the same number of ETH on L2 in return.

<Tabs items={['depositETH', 'Full Code']}>
  <Tabs.Tab>
    <Steps>
      {<h3>Check your wallet balance on L1</h3>}

      See how much ETH you have on L1 so you can confirm that the deposit worked later on.

      ```js
            const l1Balance = await publicClientL1.getBalance({ address: account.address });
            console.log(`L1 Balance: ${formatEther(l1Balance)} ETH`); 
      ```

      <Callout type="info">
        We used `formatEther` method from `viem` to format the balance to ether.
      </Callout>

      {<h3>Create the deposit transaction</h3>}

      Use `buildDepositTransaction` to build the deposit transaction parameters on the L2.

      ```js
      const args = await publicClientL2.buildDepositTransaction({
        mint: parseEther('0.00010'), 
        to: account.address,
      });
      ```

      {<h3>Send the deposit transaction</h3>}

      Send the deposit transaction on L1 and log the L1 transaction hash.

      ```js
      const hash = await walletClientL1.depositTransaction(args);
      console.log(`Deposit transaction hash on L1: ${hash}`);
      ```

      {<h3>Wait for L1 transaction</h3>}

      Wait for the L1 transaction to be processed and log the receipt.

      ```js
      const receipt = await publicClientL1.waitForTransactionReceipt({ hash });
      console.log('L1 transaction confirmed:', receipt);
      ```

      {<h3>Extract the L2 transaction hash</h3>}

      Extracts the corresponding L2 transaction hash from the L1 receipt, and logs it.
      This hash represents the deposit transaction on L2.

      ```js
      const l2Hashes = getL2TransactionHashes(receipt);
      console.log(`Corresponding L2 transaction hash: ${l2Hashes}`);
      ```

      {<h3>Wait for the L2 transaction to be processed</h3>}

      Wait for the L2 transaction to be processed and confirmed and logs the L2 receipt to verify completion.

      ```js
      const l2Receipt = await publicClientL2.waitForTransactionReceipt({
        hash: l2Hashes,
      });
      console.log('L2 transaction confirmed:', l2Receipt);
      console.log('Deposit completed successfully!');
      ```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>
    ```js
    const { createPublicClient, http, createWalletClient, parseEther } = require('viem');
    const { sepolia, optimismSepolia } = require('viem/chains');
    const { privateKeyToAccount } = require('viem/accounts');
    const { getL2TransactionHashes, publicActionsL2, walletActionsL1, walletActionsL2 } = require('viem/op-stack');

    // Load private key from environment variable
    const PRIVATE_KEY = process.env.PRIVATE_KEY;
    const account = privateKeyToAccount(PRIVATE_KEY);

    // Create L1 public client for reading from the Sepolia network
    const publicClientL1 = createPublicClient({
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
    }).extend(publicActionsL1())

    // Create L1 wallet client for sending transactions on Sepolia
    const walletClientL1 = createWalletClient({
    account,
    chain: sepolia,
    transport: http("https://sepolia.optimism.io"),
    }).extend(walletActionsL1());

    // Create L2 public client for interacting with OP Sepolia
    const publicClientL2 = createPublicClient({
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
    }).extend(publicActionsL2());

    // Create L2 wallet client for sending transactions on OP Sepolia
    const walletClientL2 = createWalletClient({
    account,
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
    }).extend(walletActionsL2());

    async function depositETH(amount) {
    try {
        // Build the deposit transaction parameters
        const args = await publicClientL2.buildDepositTransaction({
            mint: parseEther(amount), // Convert amount to wei
            to: account.address, // Recipient on L2 (same as sender in this case)
        });

        // Execute the deposit transaction on L1
        const hash = await walletClientL1.depositTransaction(args);
        console.log(`Deposit transaction hash on L1: ${hash}`);

        // Wait for the L1 transaction to be confirmed
        const receipt = await publicClientL1.waitForTransactionReceipt({ hash });
        console.log('L1 transaction confirmed:', receipt);

        // Extract the corresponding L2 transaction hash
        const l2Hashes = getL2TransactionHashes(receipt);
        console.log(`Corresponding L2 transaction hash: ${l2Hashes}`);

        // Wait for the L2 transaction to be confirmed
        const l2Receipt = await publicClientL2.waitForTransactionReceipt({
            hash: l2Hashes,
        });
        console.log('L2 transaction confirmed:', l2Receipt);

        console.log('Deposit completed successfully!');
        } catch (error) {
            console.error('Error during deposit:', error);
        }
    }
    ```
  </Tabs.Tab>
</Tabs>

<Callout>
  Using a smart contract wallet?
  As a safety measure, `depositETH` will fail if you try to deposit ETH from a smart contract wallet without specifying a `recipient`.
  Add the `recipient` option to the `depositETH` call to fix this.
</Callout>

## Withdraw ETH

You just bridged some ETH from L1 to L2.
Nice!
Now you're going to repeat the process in reverse to bridge some ETH from L2 to L1.

<Tabs items={['withdrawETH', 'Full Code']}>
  <Tabs.Tab>
    <Steps>
      {<h3>Create the withdrawal transaction</h3>}

      Uses `buildWithdrawalTransaction` to create the withdrawal parameters.
      Converts the withdrawal amount to `wei` and specifies the recipient on L1.

      ```js
      const withdrawArgs = await publicClientL1.buildInitiateWithdrawal({
          withdrawalAmount: parseEther('0.0001'), 
          to: account.address,
      });
      ```

      {<h3>Executing the Withdrawal</h3>}

      This sends the withdrawal transaction on L2, which initiates the withdrawal process on L2 and logs a transaction hash for tracking the withdrawal.

      ```js
      const hash = await walletClientL2.initiateWithdrawal(withdrawArgs);
      console.log(`Withdrawal transaction hash on L2: ${hash}`);
      ```

      {<h3>Confirming L2 Transaction</h3>}

      Wait one hour (max) for the L2 Output containing the transaction to be proposed, and log the receipt, which contains important details like the block number etc.

      ```js
      const receipt = await publicClientL2.waitForTransactionReceipt({ hash });
      console.log('L2 transaction confirmed:', receipt);
      ```

      {<h3>Wait for Withdrawal prove</h3>}

      Next, is to prove to the bridge on L1 that the withdrawal happened on L2. To achieve that, you first need to wait until the withdrawal is ready to prove.

      ```js
      const { output, withdrawal } = await publicClientL1.waitToProve({
          receipt,
          targetChain: walletClientL2.chain
      })
      ```

      Build parameters to prove the withdrawal on the L2.

      ```js
      const proveArgs = await publicClientL2.buildProveWithdrawal({
        output,
        withdrawal,
      })
      ```

      {<h3>Prove the withdrawal on the L1</h3>}

      Once the withdrawal is ready to be proven, you'll send an L1 transaction to prove that the withdrawal happened on L2.

      ```js
      const proveHash = await walletClientL1.proveWithdrawal(proveArgs)
      ```

      ```js
      const proveReceipt = await publicClientL1.waitForTransactionReceipt({hash: proveHash})
      ```

      {<h3>Wait for withdrawal finalization</h3>}

      Before a withdrawal transaction can be finalized, you will need to wait for the finalization period.
      This can only happen after the fault proof period has elapsed. On OP Mainnet, this takes 7 days.

      ```js
      const awaitWithdrawal = await publicClientL1.waitToFinalize({
        targetChain: walletClientL2.chain,
        withdrawalHash: withdrawal.withdrawalHash,
      })

      ```

      <Callout>
        We're currently testing fault proofs on OP Sepolia, so withdrawal times
        reflect Mainnet times.
      </Callout>

      {<h3>Finalize the withdrawal</h3>}

      ```js
      const finalizeHash = await walletClientL1.finalizeWithdrawal({
        targetChain: walletClientL2.chain,
        withdrawal,
      })
      ```

      {<h3>Wait until the withdrawal is finalized</h3>}

      ```js
      const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
        hash: finalizeHash
      })
      ```

      {<h3>Check the withdrawal status</h3>}

      ```js
      const status = await publicClientL1.getWithdrawalStatus({
        receipt,
        targetChain: walletClientL2.chain
      })
      ```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>
    ```js
    const { createPublicClient, http, createWalletClient, parseEther } = require('viem');
    const { sepolia, optimismSepolia } = require('viem/chains');
    const { privateKeyToAccount } = require('viem/accounts');
    const { getL2TransactionHashes, publicActionsL2, walletActionsL1, walletActionsL2 } = require('viem/op-stack');


    // Load private key from environment variable
    const PRIVATE_KEY = process.env.PRIVATE_KEY;
    const account = privateKeyToAccount(PRIVATE_KEY);

    // Create L1 public client for reading from the Sepolia network
    const publicClientL1 = createPublicClient({
    chain: sepolia,
    transport: http("https://rpc.ankr.com/eth_sepolia"),
    }).extend(publicActionsL1())

    // Create L1 wallet client for sending transactions on Sepolia
    const walletClientL1 = createWalletClient({
    account,
    chain: sepolia,
    transport: http("https://sepolia.optimism.io"),
    }).extend(walletActionsL1());

    // Create L2 public client for interacting with OP Sepolia
    const publicClientL2 = createPublicClient({
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
    }).extend(publicActionsL2());

    // Create L2 wallet client for sending transactions on OP Sepolia
    const walletClientL2 = createWalletClient({
    account,
    chain: optimismSepolia,
    transport: http("https://sepolia.optimism.io"),
    }).extend(walletActionsL2());


    async function withdrawETH(amount) {
    try {
        const args = await publicClientL2.buildWithdrawalTransaction({
        withdrawalAmount: parseEther(amount),
        to: account.address,
        });

        const hash = await walletClientL2.initiateWithdrawal(args);
        console.log(`Withdrawal transaction hash on L2: ${hash}`);

        const receipt = await publicClientL2.waitForTransactionReceipt({ hash });
        console.log('L2 transaction confirmed:', receipt);

        const { output, withdrawal } = await publicClientL1.waitToProve({
        receipt,
        targetChain: walletClientL2.chain
        });

        const proveArgs = await publicClientL2.buildProveWithdrawal({
        output,
        withdrawal,
        });

        const proveHash = await walletClientL1.proveWithdrawal(proveArgs);

        const proveReceipt = await publicClientL1.waitForTransactionReceipt({ hash: proveHash });

        const awaitWithdrawal = await publicClientL1.waitToFinalize({
        targetChain: walletClientL2.chain,
        withdrawalHash: withdrawal.withdrawalHash,
        });

        const finalizeHash = await walletClientL1.finalizeWithdrawal({
        targetChain: walletClientL2.chain,
        withdrawal,
        });

        const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
        hash: finalizeHash
        });

        const status = await publicClientL1.getWithdrawalStatus({
        receipt,
        targetChain: walletClientL2.chain
        })

        console.log('Withdrawal completed successfully!');
    } catch (error) {
        console.error('Error during withdrawal:', error);
    }
    }
    ```
  </Tabs.Tab>
</Tabs>

## Important Considerations

<Callout type="warning">
  *   **Challenge Period**: The 7-day waiting period is crucial for security.
  *   **Gas Costs**: Withdrawals involve transactions on both L2 and L1, each incurring gas fees.
  *   **Private Key Handling**: Use secure key management practices in real applications.
  *   **RPC Endpoint Security**: Keep your Alchemy API key (or any RPC endpoint) secure.
</Callout>

## Next Steps

*   Develop a user interface for easier interaction with these bridging functions.
*   Implement robust error handling and retry mechanisms for production use.

You've just deposited and withdrawn ETH using `viem/op-stack`.
You should now be able to write applications that use `viem/op-stack` to transfer ETH between L1 and L2.
Although this tutorial used Sepolia and OP Sepolia, the same process works for Ethereum and OP Mainnet.
