---
title: Bridging ETH to OP Mainnet With Viem
lang: en-US
description: Learn how to use viem to transfer ETH between Layer 1 (Ethereum or Sepolia) and Layer 2 (OP Mainnet or OP Sepolia).
---

import { Callout, Steps, Tabs } from 'nextra/components'

# Bridging ETH to OP Mainnet With Viem

This tutorial explains how you can use the [Viem](https://viem.sh/op-stack/) to bridge ETH from L1 (Ethereum or Sepolia) to L2 (OP Mainnet or OP Sepolia).
The `viem/op-stack` library is an easy way to add bridging functionality to your JavaScript-based application.
It also provides some safety rails to prevent common mistakes that could cause ETH or ERC-20 tokens to be made inaccessible.

Make sure to check out the [Standard Bridge guide](/builders/app-developers/bridging/standard-bridge) if you want to learn more about how the bridge works under the hood.

## Prerequisites

Before you begin, ensure you have the following:

*   Familiarity with bridging concepts between L1 and L2.
*   An understanding of the [viem library](https://viem.sh/op-stack/)
*   [Node.js](https://nodejs.org/en/) (version 14 or later)
*   [pnpm](https://pnpm.io/installation) installed for managing packages.

Install `pnpm` if you haven't already:

```bash
npm install -g pnpm

```

<Steps>
  {<h3>Project Setup</h3>}

  Let's create a new project and install the necessary dependencies.

  *   Create a folder and a file

  ```bash
  mkdir op-sample-project
  cd op-sample-project
  touch bridge-eth.js
  ```

  *   Initialize the project:

  ```bash
  pnpm init
  ```

  *   Install dependencies: Install `viem`, and `dotenv` for managing environment variables.

  ```bash
  pnpm add viem dotenv
  ```

  {<h3>Configure Environment Variables</h3>}

  You need a private key in order to sign transactions.
  Create a `.env` file in your parent directory to securely store your environment variables
  Make sure this private key corresponds to an address that has ETH on Sepolia.

  ```bash
  touch .env
  ```

  Add your Ethereum Layer 1 (L1) and Optimism Layer 2 (L2) RPC endpoints, and wallet private key in the `.env` file:

  ```bash
  L1_RPC_URL=https://rpc.ankr.com/eth_sepolia
  L2_RPC_URL=https://sepolia.optimism.io
  TUTORIAL_PRIVATE_KEY=0x...
  ```
</Steps>

<Callout type="warning">
  Never share your private key and avoid committing this file to version control.
</Callout>

## Import Dependencies

{<h3>Import the necessary packages</h3>}

In the `bridge-eth.js` file, import the `viem` package at the top:

```js

// Import required modules
import { createPublicClient, http, createWalletClient, parseEther } from 'viem';
import { sepolia, optimismSepolia } from 'viem/chains';
import { privateKeyToAccount } from 'viem/accounts'
import { getL2TransactionHashes, publicActionsL2, walletActionsL1 } from 'viem/op-stack'
import * as dotenv from 'dotenv';
// Load environment variables
dotenv.config();
```

## Set Session Variables

You'll need a few variables throughout this tutorial.
Let's set those up now.

<Tabs items={['Create an account', 'Create RPC providers', 'Wallet Clients']}>
  <Tabs.Tab>
    Create an account from the private key. [`privateKeyToAccount`](https://viem.sh/docs/accounts/local/privateKeyToAccount#privatekeytoaccount) is a viem method used to sign transactions by passing a private key.

    Load your private key with `privateKeyToAccount`, after the imports above.

    ```js
    const account = privateKeyToAccount(process.env.PRIVATE_KEY);
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    Next, set up our viem clients for the L1(Sepolia) and L2(optimismSepolia)

    <Steps>
      {<h3>L1 (Sepolia) publicClientL1 </h3>}

      ```js
      const publicClientL1 = createPublicClient({
          chain: sepolia,
          transport: http(process.env.L1_RPC_URL),
      });
      ```

      {<h3>L2 (optimismSepolia) publicClientL2</h3>}

      ```js
          const publicClientL2 = createPublicClient({
              chain: optimismSepolia,
              transport: http(process.env.L2_RPC_URL),
          }).extend(publicActionsL2());
      ```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>
    Also set up wallet clients for L1 and L2.

    <Steps>
      {<h3>L1 (Sepolia) walletClientL1</h3>}

      ```js
      const walletClientL1 = createWalletClient({
          account,
          chain: sepolia, /* or mainnet */
          transport: http(process.env.L1_RPC_URL),
      }).extend(walletActionsL1());
      ```

      {<h3>L2 (optimismSepolia) walletClientL2</h3>}

      ```js
          const walletClientL2 = createWalletClient({
              chain: optimismSepolia,
              transport: http(process.env.L2_RPC_URL),
          }).extend(walletActionsL1());
      ```
    </Steps>
  </Tabs.Tab>
</Tabs>

## Get ETH on Sepolia

You're going to need some ETH on L1 that you can bridge to L2.
You can get some Sepolia ETH from [this faucet](https://sepoliafaucet.com).

## Deposit ETH

Now that you have some ETH on L1 you can deposit that ETH into the `L1StandardBridge` contract. You'll then receive the same number of ETH on L2 in return.

<Tabs items={['depositETH', 'Full Code']}>
  <Tabs.Tab>
    <Steps>
      {<h3>Check your wallet balance on L1</h3>}

      See how much ETH you have on L1 so you can confirm that the deposit worked later on.

      ```js
        const checkBalances = async () => {
            const l1Balance = await publicClientL1.getBalance({ address: account.address });
            console.log(`L1 Balance: ${formatEther(l1Balance)} ETH`); 
        };
        checkBalances();
      ```

      <Callout type="info">
        We used `formatEther` method from `viem` to format the balance to ether.
      </Callout>

      {<h3>Create the deposit transaction</h3>}

      Use `buildDepositTransaction` to build the deposit transaction parameters on the L2.

      ```js
      const args = await publicClientL2.buildDepositTransaction({
        mint: parseEther('0.006942'), // Specify the amount of ETH to deposit.
        to: account.address, // Sets the recipient address on L2 (same as the sender in this case).
      });
      ```

      {<h3>Send the deposit transaction</h3>}

      Send the deposit transaction on L1 and log the L1 transaction hash.

      ```js
      const hash = await walletClientL1.depositTransaction(args);
      console.log(`Deposit transaction hash on L1: ${hash}`);
      ```

      {<h3>Wait for L1 transaction</h3>}

      Wait for the L1 transaction to be processed and log the receipt.

      ```js
      const receipt = await publicClientL1.waitForTransactionReceipt({ hash });
      console.log('L1 transaction confirmed:', receipt);
      ```

      {<h3>Extract the L2 transaction hash</h3>}

      Extracts the corresponding L2 transaction hash from the L1 receipt, and logs it.
      This hash represents the deposit transaction on L2.

      ```js
      const l2Hashes = getL2TransactionHashes(receipt);
      console.log(`Corresponding L2 transaction hash: ${l2Hashes}`);
      ```

      {<h3>Wait for the L2 transaction to be processed</h3>}

      Wait for the L2 transaction to be processed and confirmed and logs the L2 receipt to verify completion.

      ```js
      const l2Receipt = await publicClientL2.waitForTransactionReceipt({
        hash: l2Hashes,
      });
      console.log('L2 transaction confirmed:', l2Receipt);
      console.log('Deposit completed successfully!');
      ```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>
    ```javascript
    import { createPublicClient, http, createWalletClient, parseEther } from 'viem';
    import { sepolia, optimismSepolia } from "viem/chains";
    import { privateKeyToAccount } from 'viem/accounts';
    import { getL2TransactionHashes, publicActionsL2, walletActionsL1, walletActionsL2 } from 'viem/op-stack';

    // Replace with your actual private key (Keep this secure!)
    const PRIVATE_KEY = '0x....'
    const account = privateKeyToAccount(PRIVATE_KEY);

    // Create L1 public client for reading from the Sepolia network
    const publicClientL1 = createPublicClient({
        chain: sepolia,
        transport: http(process.env.L1_RPC_URL),
    });

    // Create L1 wallet client for sending transactions on Sepolia
    const walletClientL1 = createWalletClient({
        account,
        chain: sepolia,
        transport: http(process.env.L1_RPC_URL),
    }).extend(walletActionsL1());

    // Create L2 public client for interacting with OP Sepolia
    const publicClientL2 = createPublicClient({
        chain: optimismSepolia,
        transport: http(process.env.L1_RPC_URL),
    }).extend(publicActionsL2());

    // Create L2 wallet client for sending transactions on OP Sepolia
    const walletClientL2 = createWalletClient({
        account,
        chain: optimismSepolia,
        transport: http(process.env.L1_RPC_URL),
    }).extend(walletActionsL2());

    async function depositETH(amount) {
    try {
        // Build the deposit transaction parameters
        const args = await publicClientL2.buildDepositTransaction({
            mint: parseEther(amount), // Convert amount to wei
            to: account.address, // Recipient on L2 (same as sender in this case)
        });

        // Execute the deposit transaction on L1
        const hash = await walletClientL1.depositTransaction(args);
        console.log(`Deposit transaction hash on L1: ${hash}`);

        // Wait for the L1 transaction to be confirmed
        const receipt = await publicClientL1.waitForTransactionReceipt({ hash });
        console.log('L1 transaction confirmed:', receipt);

        // Extract the corresponding L2 transaction hash
        const l2Hashes = getL2TransactionHashes(receipt);
        console.log(`Corresponding L2 transaction hash: ${l2Hashes}`);

        // Wait for the L2 transaction to be confirmed
        const l2Receipt = await publicClientL2.waitForTransactionReceipt({
            hash: l2Hashes,
        });
        console.log('L2 transaction confirmed:', l2Receipt);

        console.log('Deposit completed successfully!');
        } catch (error) {
            console.error('Error during deposit:', error);
        }
    }
    ```
  </Tabs.Tab>
</Tabs>

<Callout>
  Using a smart contract wallet?
  As a safety measure, `depositETH` will fail if you try to deposit ETH from a smart contract wallet without specifying a `recipient`.
  Add the `recipient` option to the `depositETH` call to fix this.
</Callout>

## Withdraw ETH

You just bridged some ETH from L1 to L2.
Nice!
Now you're going to repeat the process in reverse to bridge some ETH from L2 to L1.

<Tabs items={['withdrawETH', 'Full Code']}>
  <Tabs.Tab>
    <Steps>
      {<h3>Create the withdrawal transaction</h3>}

      Uses `buildWithdrawalTransaction` to create the withdrawal parameters.
      Converts the withdrawal amount to `wei` and specifies the recipient on L1.

      ```js
      const args = await publicClientL2.buildWithdrawalTransaction({
          withdrawalAmount: parseEther(amount), 
          to: account.address,
      });
      ```

      {<h3>Executing the Withdrawal</h3>}

      This sends the withdrawal transaction on L2, which initiates the withdrawal process on L2 and logs a transaction hash for tracking the withdrawal.

      ```js
      const hash = await walletClientL2.initiateWithdrawal(args);
      console.log(`Withdrawal transaction hash on L2: ${hash}`);
      ```

      {<h3>Confirming L2 Transaction</h3>}

      Wait one hour (max) for the L2 Output containing the transaction to be proposed, and log the receipt, which contains important details like the block number etc.

      ```js
      const receipt = await publicClientL2.waitForTransactionReceipt({ hash });
      console.log('L2 transaction confirmed:', receipt);
      ```

      {<h3>Wait for Withdrawal prove</h3>}

      Next, is to prove to the bridge on L1 that the withdrawal happened on L2. To achieve that, you first need to wait until the withdrawal is ready to prove.

      ```js
      const { output, withdrawal } = await publicClientL1.waitToProve({
          receipt,
          targetChain: walletClientL2.chain
      })
      ```

      Build parameters to prove the withdrawal on the L2.

      ```js
      const proveArgs = await publicClientL2.buildProveWithdrawal({
        output,
        withdrawal,
      })
      ```

      {<h3>Prove the withdrawal on the L1</h3>}

      Once the withdrawal is ready to be proven, you'll send an L1 transaction to prove that the withdrawal happened on L2.

      ```js
      const proveHash = await walletClientL1.proveWithdrawal(proveArgs)
      ```

      ```js
      const proveReceipt = await publicClientL1.waitForTransactionReceipt({hash: proveHash})
      ```

      {<h3>Wait for withdrawal finalization</h3>}

      Before a withdrawal transaction can be finalized, you will need to wait for the finalization period.
      This can only happen after the fault proof period has elapsed. On OP Mainnet, this takes 7 days.

      ```js
      const awaitWithdrawal = await publicClientL1.waitToFinalize({
        targetChain: walletClientL2.chain,
        withdrawalHash: withdrawal.withdrawalHash,
      })

      ```

      <Callout>
        We're currently testing fault proofs on OP Sepolia, so withdrawal times
        reflect Mainnet times.
      </Callout>

      {<h3>Finalize the withdrawal</h3>}

      ```js
      const finalizeHash = await walletClientL1.finalizeWithdrawal({
        targetChain: walletClientL2.chain,
        withdrawal,
      })
      ```

      {<h3>Wait until the withdrawal is finalized</h3>}

      ```js
      const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
        hash: finalizeHash
      })
      ```

      {<h3>Check the withdrawal status</h3>}

      ```js
      const status = await publicClientL1.getWithdrawalStatus({
        receipt,
        targetChain: walletClientL2.chain
      })
      ```
    </Steps>
  </Tabs.Tab>

  <Tabs.Tab>
    ```js
    import { createPublicClient, http, createWalletClient, parseEther } from 'viem';
    import { sepolia, optimismSepolia } from "viem/chains";
    import { privateKeyToAccount } from 'viem/accounts';
    import { getL2TransactionHashes, publicActionsL2, walletActionsL1, walletActionsL2 } from 'viem/op-stack';

    // Replace with your actual private key (Keep this secure!)
    const PRIVATE_KEY = '0x....'
    const account = privateKeyToAccount(PRIVATE_KEY);

    // Create L1 public client for reading from the Sepolia network
    const publicClientL1 = createPublicClient({
        chain: sepolia,
        transport: http(process.env.L1_RPC_URL),
    });

    // Create L1 wallet client for sending transactions on Sepolia
    const walletClientL1 = createWalletClient({
        account,
        chain: sepolia,
        transport: http(process.env.L1_RPC_URL),
    }).extend(walletActionsL1());

    // Create L2 public client for interacting with OP Sepolia
    const publicClientL2 = createPublicClient({
        chain: optimismSepolia,
        transport: http(process.env.L2_RPC_URL),
    }).extend(publicActionsL2());

    // Create L2 wallet client for sending transactions on OP Sepolia
    const walletClientL2 = createWalletClient({
        account,
        chain: optimismSepolia,
        transport: http(process.env.L2_RPC_URL),
    }).extend(walletActionsL2());

    async function withdrawETH(amount) {
        try {
            const args = await publicClientL2.buildWithdrawalTransaction({
            withdrawalAmount: parseEther(amount),
            to: account.address,
            });

            const hash = await walletClientL2.initiateWithdrawal(args);
            console.log(`Withdrawal transaction hash on L2: ${hash}`);

            const receipt = await publicClientL2.waitForTransactionReceipt({ hash });
            console.log('L2 transaction confirmed:', receipt);

            const { output, withdrawal } = await publicClientL1.waitToProve({
            receipt,
            targetChain: walletClientL2.chain
            });

            const proveArgs = await publicClientL2.buildProveWithdrawal({
            output,
            withdrawal,
            });

            const proveHash = await walletClientL1.proveWithdrawal(proveArgs);

            const proveReceipt = await publicClientL1.waitForTransactionReceipt({ hash: proveHash });

            const awaitWithdrawal = await publicClientL1.waitToFinalize({
            targetChain: walletClientL2.chain,
            withdrawalHash: withdrawal.withdrawalHash,
            });

            const finalizeHash = await walletClientL1.finalizeWithdrawal({
            targetChain: walletClientL2.chain,
            withdrawal,
            });

            const finalizeReceipt = await publicClientL1.waitForTransactionReceipt({
            hash: finalizeHash
            });

            const status = await publicClientL1.getWithdrawalStatus({
            receipt,
            targetChain: walletClientL2.chain
            })

            console.log('Withdrawal completed successfully!');
        } catch (error) {
            console.error('Error during withdrawal:', error);
        }
    }
    ```
  </Tabs.Tab>
</Tabs>

## Important Considerations

<Callout type="warning">
  *   **Challenge Period**: The 7-day waiting period is crucial for security.
  *   **Gas Costs**: Withdrawals involve transactions on both L2 and L1, each incurring gas fees.
  *   **Private Key Handling**: Use secure key management practices in real applications.
  *   **RPC Endpoint Security**: Keep your Alchemy API key (or any RPC endpoint) secure.
</Callout>

## Next Steps

*   Develop a user interface for easier interaction with these bridging functions.
*   Implement robust error handling and retry mechanisms for production use.

You've just deposited and withdrawn ETH using `viem/op-stack`.
You should now be able to write applications that use `viem/op-stack` to transfer ETH between L1 and L2.
Although this tutorial used Sepolia and OP Sepolia, the same process works for Ethereum and OP Mainnet.
