---
title: Transaction Finality
lang: en-US
description: Learn about finality in OP Stack and the steps to achieve transaction settlement.
---

import Image from 'next/image'
import { Callout } from 'nextra/components'

# Overview

This guide explains how transaction finality works in OP Stack, covering the fundamental concepts of Fault Proofs and Challenges.

OP Stack is an extension of Ethereum's consensus mechanism. Instead of running an entirely separate consensus protocol, the OP Stack leverages Ethereum's consensus.
This enables it to take advantage of Ethereum's transaction ordering mechanism and finalize its own blocks without requiring a new consensus layer.

## Sequencer trust assumptions

The sequencer operates with the following trust assumptions:

*   It can temporarily withhold transactions.
*   It may attempt to reorder transactions before L1 publication.
*   Once transactions are published on L1, the sequencer cannot modify or censor them.
*   The sequencer cannot affect finalized transactions.

## Transaction finality states

In the OP Stack, transaction finality progresses through three key stages:

1.  **Unsafe:** The sequencer creates a block containing the transaction, but the transaction data has not yet been posted to Ethereum (L1). The block is circulated within the L2 network for speed.

2.  **Safe:** The batcher posts the transaction data to L1. At this point, any L2 node can derive the transaction.

3.  **Finalized:** Transactions are finalized once more than 65 Ethereum blocks (approximately 10-15 minutes) have passed, ensuring that the L1 data is secure and cannot be reorganized.

<Image src="/img/op-stack/protocol/tx-finality.png" alt="Transaction Finality Diagram." width={0} height={0} sizes="100vw" style={{ width: '100%', height: 'auto' }} quality={100} />

### Transaction validity

When a transaction is submitted to the network, it is either valid or invalid. If the transaction is valid, the sequencer puts it in a block. If it is invalid, the transaction is discarded. There is no way the sequencer can write an invalid transaction to a new block.

### Reorgs and finality
Once a transaction is included in a finalized Ethereum block, it cannot be reorganized. 

If an Ethereum reorganization (reorg) occurs:

1.  L2 nodes detect the L1 reorg.
2.  Affected L2 blocks revert to an "unsafe" status.
3.  The sequencer typically republishes the same transactions.
4.  The system returns to a consistent state after reprocessing.

## Common misconceptions

The proof system is entirely separate from the core OP Stack protocol. It is an application-level validation system designed to ensure the accuracy of certain claims about the transaction state.

### The role of proof system

The following is a quick refresher on the Fault Proof System. It is a system designed to ensure the accuracy of certain claims about the transaction state on the L2.

A claim in the context of OP Stack is a statement asserting the state of the system at a specific block height. For instance, a claim might assert that at block 1,000,000, the state hash is `XYZ`. If other participants believe this claim to be incorrect, they can challenge it.

Challenges focus on proving whether a given claim is valid. The outcome of a challenge does not impact the underlying chain. For example, if a claim about the transaction state at a specific block is proven wrong, it only affects the application level functionality and does not alter the OP Stack protocol.

The challenge period provides time for challenges to be raised and resolved.
Although OP Stack finalizes transactions quickly (within 20 minutes), the 7-day challenge window serves two critical purposes:

1.  It allows time to dispute the correctness of output state roots posted to Ethereum by the proposer.
2.  It provides a security period for withdrawal processing, ensuring the integrity of cross-chain operations.

### Bridge independence

Key aspects of bridge systems include:

*   Bridges are application-level constructs.
*   They operate independently of the core OP Stack protocol.
*   Bridge security does not affect the validity of L2 transactions.
*   Bridge failures do not cause L2 reorgs or state changes.

For example, a custom bridge might be developed to allow ERC-20 tokens to move between layers. However, this bridge is application-level and not native to the OP Stack. If there is an issue with the bridge, such as incorrect proof validation, it does not impact the protocol itself but affects the subjective value of the bridged assets.

### Withdrawal delays vs. finality

One common misconception is confusing withdrawal delays with transaction finality:

*   Transaction finality occurs in approximately 20 minutes.
*   Withdrawal delays (often 7 days) are separate from transaction finality.
*   Withdrawal delays are application-level security features.
*   These delays affect only L1 withdrawals, not L2 transaction finality.

## Conclusion

Transaction finality in the OP Stack relies on Ethereum's consensus mechanism. The OP Stack inherits Ethereum's finality guarantees, while the proof system adds a layer of validation for app-level functionality.
