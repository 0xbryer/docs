---
title: Transaction Finality
lang: en-US
description: Learn about finality in OP Stack and the steps to achieve transaction settlement.
---

import Image from 'next/image'
import { Callout } from 'nextra/components'

# Transaction finality

This guide explains how transaction finality works in the OP Stack and addresses common misconceptions around transaction finality and the Fault Proof System.
The OP Stack derives its security from Ethereum by utilizing Ethereum's consensus mechanism. Instead of running an entirely separate consensus protocol, the OP Stack derives a layer 2 blockchain by reading the finalized state on Ethereum.
This enables it to take advantage of Ethereum's transaction ordering mechanism and finalize its own blocks without requiring a new consensus layer.


## Sequencer Operations

The sequencer (block producer) processes transactions in the following steps:

1.  Pre-publishing Distribution:
    *   The sequencer receives transactions from users.
    *   It creates blocks containing these transactions.
    *   It distributes these blocks to network nodes before L1 publication.
    *   Nodes mark these blocks as "unsafe."

2.  L1 Publication:
    *   The sequencer publishes the blocks to Ethereum (L1).
    *   Once included in L1, the blocks are marked as "safe."
    *   Blocks achieve "finalized" status after L1 finalization (approximately 20 minutes).

### Sequencer Trust Assumptions

The sequencer operates with the following trust assumptions:

*   It can temporarily withhold transactions.
*   It may attempt to reorder transactions before L1 publication.
*   Once transactions are published on L1, the sequencer cannot modify or censor them.
*   The sequencer cannot affect finalized transactions.

## Transaction Finality States

In the OP Stack, transaction finality progresses through three key stages:

1.  **Unsafe:** The sequencer creates a block containing the transaction, but the transaction data has not yet been posted to Ethereum (L1). The block is circulated within the L2 network for speed.

2.  **Safe:** The batcher posts the transaction data to L1. At this point, any L2 node can derive the transaction.

3.  **Finalized:** Transactions are finalized once more than 65 Ethereum blocks (approximately 10-15 minutes) have passed, ensuring that the L1 data is secure and cannot be reorganized.

<Image src="/img/op-stack/protocol/tx-finality.png" alt="Transaction Finality Diagram." width={0} height={0} sizes="100vw" style={{ width: '100%', height: 'auto' }} quality={100} />

### Transaction Validity

When a block is submitted to Ethereum, it is either valid or invalid. If the block is valid, the state is updated accordingly. If it is invalid, the block is discarded. Nodes execute valid blocks and update the state as required.

### Reorgs and Finality

Once a block is included in a finalized Ethereum block, it cannot be reorganized. Therefore, blocks enjoy the same finality guarantees as Ethereum blocks, and this finality is managed by the OP Stack architecture.

### Handling Reorgs

If an Ethereum reorganization (reorg) occurs:

1.  L2 nodes detect the L1 reorg.
2.  Affected L2 blocks revert to an "unsafe" status.
3.  The sequencer typically republishes the same transactions.
4.  The system returns to a consistent state after reprocessing.

## The Role of the Proof System

The proof system is entirely separate from the core OP Stack protocol. It is an application-level validation system designed to ensure the accuracy of certain claims about the transaction state.

### What Is a Claim?

A claim in the context of OP Stack is a statement asserting the state of the system at a specific block height. For instance, a claim might assert that at block 1,000,000, the state hash is `XYZ`. If other participants believe this claim to be incorrect, they can challenge it.

### Fault Proofs and Challenges

Challenges focus on proving whether a given claim is valid. The outcome of a challenge does not impact the underlying chain. For example, if a claim about the transaction state at a specific block is proven wrong, it only affects the app-level functionality and does not alter the OP Stack protocol.

## 7-Day Challenge Period in OP Stack

The 7-day challenge period provides time for challenges to be raised and resolved.
Although OP Stack finalizes transactions quickly (within 20 minutes), the 7-day challenge window serves two critical purposes:

1.  It allows time to validate and dispute the correctness of batches posted to Ethereum by the op-batcher, particularly important in scenarios like 51% attacks.
2.  It provides a security period for withdrawal processing, ensuring the integrity of cross-chain operations.

### Why Seven Days?

The 7-day challenge period is a reasonable time frame that allows participants to organize a response, potentially even initiating a L1 hard fork to address critical issues. In the OP Stack, this challenge period also serves as a safeguard for app-level bridges and custom designs that may be built on top of the core protocol.

### Bridge Independence

Key aspects of bridge systems include:

*   Bridges are application-level constructs.
*   They operate independently of the core OP Stack protocol.
*   Bridge security does not affect the validity of L2 transactions.
*   Bridge failures do not cause L2 reorgs or state changes.

### Example: Custom Bridges in OP Stack

A custom bridge might be developed by a user to allow ERC-20 tokens to move between layers. However, this bridge is application-level and not native to the OP Stack. If there is an issue with the bridge, such as incorrect proof validation, it does not impact the protocol itself but affects the subjective value of the bridged assets.

### Withdrawal Delays vs. Finality

One common misconception is confusing withdrawal delays with transaction finality:

*   Transaction finality occurs in approximately 20 minutes.
*   Withdrawal delays (often 7 days) are separate from transaction finality.
*   Withdrawal delays are application-level security features.
*   These delays affect only L1 withdrawals, not L2 transaction finality.

## Conclusion

Transaction finality in the OP Stack relies on Ethereum's consensus mechanism. The OP Stack inherits Ethereum's finality guarantees, while the proof system adds a layer of validation for app-level functionality.
