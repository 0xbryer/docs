---
title: How to transfer a SuperchainERC20
lang: en-US
description: Learn how to transfer a SuperchainERC20 between chains using L2ToL2CrossDomainMessenger.
---

import { Callout, Steps } from 'nextra/components'

# How to transfer a SuperchainERC20

This guide walks you through transferring SuperchainERC20 tokens between chains using the `L2ToL2CrossDomainMessenger` contract.

## Prerequisites

Before you begin, ensure you have:

*   Access to source and destination chain RPC endpoints
*   A private key with funds on both chains
*   The `cast` command-line tool installed

<Callout type="info">
  All commands in this guide use the `cast` CLI tool. Make sure you have it properly configured with your RPC endpoints.
</Callout>

## Contract addresses

The following contracts are used in this guide:

*   L2NativeSuperchainERC20: `0x420beeF000000000000000000000000000000001`
*   L2ToL2CrossDomainMessenger: `0x4200000000000000000000000000000000000023`

## How it works

Transferring tokens involves two main phases:

1.  **Source chain operations**: Mint tokens and initiate the transfer
2.  **Destination chain operations**: Relay the message to complete the transfer

<Callout type="warning">
  Always verify your addresses and amounts before sending transactions. Cross-chain transfers cannot be reversed.
</Callout>

<Steps>

### Step 1: Mint tokens

First, mint tokens on the source chain:

```bash
cast send 0x420beeF000000000000000000000000000000001 \
"mint(address _to, uint256 _amount)" \
YOUR_ADDRESS 1000 \
--rpc-url SOURCE_CHAIN_RPC \
--private-key YOUR_PRIVATE_KEY
```

<Callout type="default">
  Replace `YOUR_ADDRESS`, `SOURCE_CHAIN_RPC`, and `YOUR_PRIVATE_KEY` with your actual values.
</Callout>

### Step 2: Initiate transfer

After minting, initiate the bridge transfer:

```bash
cast send 0x4200000000000000000000000000000000000028 \
"sendERC20(address _token, address _to, uint256 _amount, uint256 _chainId)" \
0x420beeF000000000000000000000000000000001 \
RECIPIENT_ADDRESS 1000 DESTINATION_CHAIN_ID \
--rpc-url SOURCE_CHAIN_RPC \
--private-key YOUR_PRIVATE_KEY
```

<Callout type="important">
  The transfer isn't complete until you relay the message on the destination chain.
</Callout>

### Step 3: Get message details

Retrieve the message details from the L2ToL2CrossDomainMessenger:

```bash
cast logs \
--address 0x4200000000000000000000000000000000000023 \
--rpc-url SOURCE_CHAIN_RPC
```

<Callout type="info">
  Note down the `blockNumber`, `logIndex`, and timestamp - you'll need these for relaying.
</Callout>

### Step 4: Relay the message

Complete the transfer by relaying the message on the destination chain:

```bash
cast send 0x4200000000000000000000000000000000000023 \
--gas-limit 200000 \
"relayMessage((address, uint256, uint256, uint256, uint256), bytes)" \
"(0x4200000000000000000000000000000000000023, BLOCK_NUMBER, LOG_INDEX, TIMESTAMP, SOURCE_CHAIN_ID)" \
MESSAGE_PAYLOAD \
--rpc-url DESTINATION_CHAIN_RPC \
--private-key YOUR_PRIVATE_KEY
```

### Step 5: Verify transfer

Check the balance on the destination chain:

```bash
cast balance \
--erc20 0x420beeF000000000000000000000000000000001 \
RECIPIENT_ADDRESS \
--rpc-url DESTINATION_CHAIN_RPC
```
</Steps>

## Alternative methods

You can also use:

*   `supersim --interop.autorelay` for development environments
*   [viem bindings/actions](https://supersim.pages.dev/guides/interop/relay-using-viem) for TypeScript integration

## Next steps

*   Read the [Superchain Interop Explainer](/stack/interop/explainer#faqs) or check out this [Superchain interop design video walk-thru](https://www.youtube.com/watch?v=FKc5RgjtGes).
*   Use [Supersim](supersim), a local dev environment that simulates Superchain interop for testing applications against a local version of the Superchain.
